# 时间序列数据库 (TSDB) 的初识和选择

## **时间序列模型** 

时间序列数据库主要用于处理带时间标签（按照时间的顺序变化，即时间序列化）的数据，带时间标签的数据也称为时间序列数据。

每个时序点结构如下：

- **timestamp:** 数据点的时间，表示数据发生的时间
- **metric:** 指标名，当前数据的标识，有些系统中也称为 name
- **value:** 值，数据的数值，一般为 double 类型，如 cpu 使用率，访问量等数值，有些系统一个数据点只能有一个 value，多个 value 就是多条时间序列。有些系统可以有多个 value 值，用不同的 key 表示
-  **tag:** 附属属性

## 实现

假如我想记录一系列传感器的时间序列数据。数据结构如下：

```javascript
* 标识符：device_id，时间戳
* 元数据：location_id，dev_type，firmware_version，customer_id
* 设备指标：cpu_1m_avg，free_mem，used_mem，net_rssi，net_loss，电池
* 传感器指标：温度，湿度，压力，CO，NO2，PM10
```

如果使用传统 RDBMS 存储，最简单，但在性能，高效存储，高可用，分布式和易用性上不足。

大家可以思考思考，如果让我们自己来实现一个时间序列数据库，你会怎么设计，你会考虑哪些性能上的优化，又如何做到高可用，怎样做到简单易用。

## **Timescale**

基于postgresql 改造的时间序列数据库，其特点如下：

**基础：**

- 支持所有 PostgreSQL 原生 SQL，包含完整 SQL 接口（包括辅助索引，非时间聚合，子查询，JOIN，窗口函数）。
- 用 PostgreSQL 的客户端或工具，可以直接应用到该数据库，不需要更改。
- 时间为导向的特性，API 功能和相应的优化。
- 可靠的数据存储。

**扩展：**

- 透明时间 / 空间分区，用于放大（单个节点）和扩展。
- 高数据写入速率（包括批量提交，内存中索引，事务支持，数据备份支持)。
- 单个节点上的大小合适的块（二维数据分区），以确保即使在大数据量时也可快速读取。
- 块之间和服务器之间的并行操作。

**劣势：**

- 因为 TimescaleDB 没有使用列存技术，它对时序数据的压缩效果不太好，压缩比最高在 4X 左右
- 目前暂时不完全支持分布式的扩展（正在开发相关功能），所以会对服务器单机性能要求较高

## **Influxdb** 

Influxdb 是业界比较流行的一个时间序列数据库，特别是在 IOT 和监控领域十分常见。其使用 go 语言开发，突出特点是性能。**特性：**

- 高效的时间序列数据写入性能。自定义 TSM 引擎，快速数据写入和高效数据压缩。
- 无额外存储依赖。
- 简单，高性能的 HTTP 查询和写入 API。
- 以插件方式支持许多不同协议的数据摄入，如：graphite，collectd，和 openTSDB
- SQL-like 查询语言，简化查询和聚合操作。
- 索引 Tags，支持快速有效的查询时间序列。
- 保留策略有效去除过期数据。
- 连续查询自动计算聚合数据，使频繁查询更有效。

Influxdb 已经将分布式版本转为闭源。所以在分布式集群这块是一个弱点，需要自己实现。

## **OpenTSDB** 

基于 Hadoop 和 HBase（新版也支持 Cassandra），通过独立的 Time Series Demon (TSD) 提供服务，所以它可以通过增减服务节点来轻松扩缩容。

- 受限于 Hbase，存储空间较大，压缩不足。依赖整套 HBase, ZooKeeper
- 采用无模式的 tagset 数据结构 (sys.cpu.user 1436333416 23 host=web01 user=10001) 结构简单，多 value 查询不友好
-  HTTP-DSL 查询

## **Druid** 

Druid 是一个实时在线分析系统 (LOAP)。其架构融合了实时在线数据分析，全文检索系统和时间序列系统的特点，使其可以满足不同使用场景的数据存储。

- 采用列式存储：支持高效扫描和聚合，易于压缩数据。
- 可伸缩的分布式系统：Druid 自身实现可伸缩，可容错的分布式集群架构。部署简单。
- 强大的并行能力：Druid 各集群节点可以并行地提供查询服务。
- 实时和批量数据摄入：Druid 可以实时摄入数据，如通过 Kafka。也可以批量摄入数据，如通过 Hadoop 导入数据。
- 自恢复，自平衡，易于运维：Druid 自身架构即实现了容错和高可用。不同的服务节点可以根据负载需求添加或减少节点。
- 容错架构，保证数据不丢失：Druid 数据可以保留多副本。另外可以采用 HDFS 作为深度存储，来保证数据不丢失。
- 索引：Druid 对 String 列实现反向编码和 Bitmap 索引，所以支持高效的 filter 和 groupby。
- 基于时间分区：Druid 对原始数据基于时间做分区存储，所以 Druid 对基于时间的范围查询将更高效。
- 自动预聚合：Druid 支持在数据摄入期就对数据进行预聚合处理。

Druid 架构蛮复杂的。其按功能将整个系统细分为多种服务，query、data、master 不同职责的系统独立部署，对外提供统一的存储和查询服务。其以分布式集群服务的方式提供了一个底层数据存储的服务。

## **Elasticsearch** 

Elasticsearch 是一个分布式的开源搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch 在 Apache Lucene 的基础上开发而成，由 Elasticsearch N.V.（即现在的 Elastic）于 2010 年首次发布。Elasticsearch 以其简单的 REST 风格 API、分布式特性、速度和可扩展性而闻名。

Elasticsearch 以 ELK stack 被人所熟知。有些公司基于 ELK 开发 metric 监控系统，对 Elasticserach 的 mapping 做相应的优化，使其更适合存储时间序列数据模型。Elasticsearch 新版本也开始发布 Metrics 组件和 APM 组件，并大量的推广其全文检索外，对时间序列的存储能力。

## **Beringei** 

Beringei 是 Facebook 在 2017 年开源的一个时序数据存储引擎，基于其 2015 年的论文《Gorilla: A Fast, Scalable, In-Memory Time Series Database 》，具有快速读写和高压缩比等特性。

Beringei 使用 Delta-of-Delta 算法存储数据，使用 XOR 编码压缩数值。使其可以用很少的内存即可存储下大量的数据。

## **如何选择一个适合自己的时间序列数据库** 

- Data model 时间序列数据模型一般有两种，一种无 schema，具有多 tag 的模型，还有一种 name、timestamp、value 型。前者适合多值模式，对复杂业务模型更适合。后者更适合单维数据模型。
- Query language 目前大部分 TSDB 都支持基于 HTTP 的 SQL-like 查询。
- Reliability 一个优秀的系统，应该有一个优雅而高可用的架构设计。简约而稳定。
- Performance 当我们开始考虑更细分领域的数据存储时，除了数据模型的需求之外，很大的原因都是通用的数据库系统在性能上无法满足我们的需求。大部分时间序列库倾向写多读少场景，用户需要平衡自身的需求。
- Ecosystem 使用的人多了，未被发现的坑也将少了。另外好的生态，其周边边界系统将十分成熟，这让我们在对接其他系统时会有更多成熟的方案。
- Operational management 易于运维，易于操作。
- Company and support 一个系统其背后的支持公司也是比较重要的。背后有一个强大的公司或组织，这在项目可用性保证和后期维护更新上都会有较大的体验。

## **性能对比** 

|                    | Timescale | InfluxDB | OpenTSDB | Druid    | Elasticsearch | Beringei |
| :----------------- | :-------- | :------- | :------- | :------- | :------------ | :------- |
| write(single node) | 15K/sec   | 470k/sec | 32k/sec  | 25k/sec  | 30k/sec       | 10m/sec  |
| write(5 node)      |           |          | 128k/sec | 100k/sec | 120k/sec      |          |

## 总结

- 如果你想要一个极限性能的系统可以考虑 Beringei 和 InfluxDB，在数据高可用方面，可以采用客户端双写模式来对数据做一个副本，保证数据的可用性。
- 如果你数据量不大，性能要求也不是特别高，却又点查询，删除和关联查询等需求，不妨考虑一下 Timescale。
- 如果你间距索引和时间序列的需求。那么 Druid 和 Elasticsearch 是最好的选择。其性能都不差，并且都是高可用容错架构。



原文：https://www.cnblogs.com/uniqueDong/p/12256938.html

修改者：Sunt