#### 事务的ACID

InnoDB是怎么保证原子性的？

- **InnoDB** 实现回滚，靠的是 undo log：当事务对数据库进行修改时，InnoDB 会生成对应的 undo log；如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。
- undo log 属于逻辑日志，它记录的是 sql 执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：对于每个 insert，回滚时会执行 delete；对于每个 delete，回滚时会执行 insert；对于每个 update，回滚时会执行一个相反的 update，把数据改回去。

InnoDB怎么保证持久性的？

- 是利用 Innodb 的 redo log。
  - 当做数据修改的时候，不仅在内存中操作，还会在 `redo log` 中记录这次操作。
  - 当事务提交的时候，会将 `redo log` 日志进行刷盘
  - 当数据库宕机重启的时候，会将 `redo log` 中的内容恢复到数据库中，再根据 `undo log` 和 `binlog` 内容决定回滚数据还是提交数据。
- 将 `redo log` 进行刷盘比直接脏页刷盘效率高：
  - redo log只记录了哪一页修改了什么，体积小，刷盘快，而脏页一页16KB
  - redo log是append only，速度快，而脏页可能涉及大量随机IO

InnoDB 怎么保证隔离性的？

- 通过MVCC和锁机制。

InnoDB是怎么保证一致性的？

- 用原子性、持久性、隔离性、schema等一起保证。

#### 并发事务会产生的问题

- 脏读：当前事务 (A) 中可以读到其他事务 (B) 未提交的数据（脏数据）
- 修改丢失：事务A、B都想对数据进行自增操作，但是事务A写入数据后被事务B覆盖了，导致1+1=1
- 不可重复读：在事务 A 中先后两次读取同一个数据，两次读取的结果不一样
- 幻读：在事务 A 中按照某个条件先后两次查询数据库，两次查询结果的条数不同

#### 事务隔离级别

- READ UNCOMMITED(未提交读)
  - 在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少
- READ COMMITED(提交读)
  - 同一个事务里面的每一次查询都会获得一个新的 read view 副本
  - 会有不可重复读问题：同一个事务里前后读取数据可能不一致
  - 是Oracle的默认隔离级别
- REPEATABLE READ(可重复读)
  - 一个事务里只会获取一次 read view 副本，从而保证每次查询的数据都是一样的。
  - 是Oracle的默认隔离级别：在 SQL 标准中，可重复读是无法避免幻读问题的，但是 InnoDB 实现的 RR 避免了幻读问题
- SERIALIZABLE (串行化)
  - 强制事务串行，并发效率很低
  - 只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少

#### Innodb 的MVCC的过程

背景

- 事务 ID
  - 每次事务开启前都会从数据库获得一个自增长的事务 ID，可以从事务 ID 判断事务的执行先后顺序。

- InnoDB 的每张表中都有隐藏列
  - **DB_TRX_ID:** 记录操作该数据事务的事务 ID；
  - **DB_ROLL_PTR：**指向上一个版本数据在 undo log 里的位置指针；
  - **DB_ROW_ID:** 隐藏 ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏 ID 创建聚集索引；

- Undo log 的用途
  - 记录数据被修改之前的值
  - 当事务回滚时可以用 undo log 的数据进行恢复，保证原子性和一致性
  - 在 MVCC 中，通过读取 undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。

- Read view
  - 每个 SQL 语句执行前都会得到一个 read_view，内含当前还没 commit 的事务的 ID 号。

#### 参考

- https://www.cnblogs.com/kismetv/p/10331633.html

- https://zhuanlan.zhihu.com/p/52977862