#### 介绍

OS的访问模型取决于CPU的访问模型。Intel CPU 的访存模型是先分段再分页的模式，所以涉及到从逻辑地址 -> 线性地址 -> 物理地址的转换；这部分在 CPU 的 MMU 模块中由电路实现。

#### 分段

操作系统分配给进程的虚拟内存空间中包含五种段：数据段、代码段、BSS、堆、栈。

- 栈：存放程序中的**临时的局部变量**和**函数的参数值**。

- 堆：存放进程**运行中被动态分配的内存**，其大小不固定。

- BSS 段 (Block Started By Symbol)：存放**未初始化的全局变量**，在变量使用前由运行时初始化为零。

- 数据段：存放程序中的**静态变量**和已初始化且不为零的**全局变量**。
- 代码段：存放可执行文件的操作指令，代码段是只读的，不可进行写操作。这部分的区域在运行前已知其大小。

![image-20210405205724473](OS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E9%A1%B9.assets/image-20210405205724473.png)

#### 地址

逻辑地址是程序中使用的一个偏移量，也称虚拟地址，所以涉及到从逻辑地址 -> 线性地址 -> 物理地址的转换。

地址转换由 CPU 的 MMU（Memory Management Unit） 模块（是硬件）中的电路实现。MMU分为分段单元和分页单元，分别负责处理分段和分页。分段模型负责将 CPU 拿到的逻辑地址（主要是几个寄存器的值，GDTR，CD，DS，SS）转成一个线性地址（线性地址由 OS 生成）；分页模型就继续接着分段模型生成的线性地址得到相应的物理地址。

#### 分段实现

分段由段表实现，段表由段基址映射到段界限。每个逻辑地址都有两部分构成：段号+段偏移量。短号用作段表的索引，偏移量不应大于段界限。否则会陷入操作系统被杀死。

#### 分页实现

如果没有分页机制，那么线性地址就是物理地址。但是，为了避免碎片，一般OS都采用了分段+分页机制。

在分页机制中，由CPU生成的每个地址分为两个部分：页码（page number）和页偏移量（page offset）。页码是页表的索引，页表包含每页所在物理内存的基址。页大小从512MB到1GB不等。

分页的另外一个好处是可以共享代码，当然，这要求代码是纯代码（即可重入代码），即不能自我修改的代码。

#### 页表

一般计算机的页表都比较大（例如100万个条目），因此需要将页表存于内存中，并将页表基址寄存器指向页表。有些系统允许页表被交换到次级存储（磁盘）中。

内存中可以同时有多个进程的内容，所以每个进程都有两个寄存器：基址寄存器、界限（limit）寄存器来标志这个进程能访问的范围。这样，上下文切换时，只需要调换寄存器的值就可以了。

#### TLB

但是，这样的话访问一个字节需要两次内存访问（一次用于页表条目，一次用于字节），内存访问速度减半。

所以就产生了TLB（Translation Look-aside Buffer）。TLB是MMU的一部分，通常的大小在32~1024之间。使用TLB搜索时，TLB会将给定的key同时与所有的键比较，所以搜索速度很快，基本不增加性能负担。有的CPU采用分开的指令和数据地址的TLB，这样可以将TLB的大小扩大一倍。

TLB 为命中时，就要硬件自动处理或由操作系统中的中断来处理。如果TLB满了，就会选择一个来替换。替换的策略很多，包括LRU、Round Robin、随机替换等。有的CPU让OS来替换，还有一些自己替换。另外，有一些条目会被固定下来不替换，比如一些内核代码的条目。

另外，每一个TLB条目都有一个ASID（address-space identifier）来标志这个条目是否有效，这样上下文切换时就不需要把TLB抹除了，只需要通过ASID将其标记为无效。

#### 分页与分段

分段模型自然就是速度快，但是不灵活（只能支持少量的进程）；分页模型就是效率低，但是足够灵活（支持大量的进程）；所以 CPU 引入了缓存 ——TLB。早期CPU能力弱，支持的进程不多，所以分段模型就够了，后来CPU能力迅速提高，能支持的进程数十倍的增长了，但是CPU是向下兼容的，所以Intel的CPU都有分段模型。









