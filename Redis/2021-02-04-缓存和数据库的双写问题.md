### 最严格的方式：读写串行化

把读写请求塞到一个内存队列中。

这会导致系统的吞吐量大幅度下降，但是一致性是能得到保证的。

### Cache Aside Pattern

**读**：缓存没有就读数据库，然后写缓存。

**更新**：先写数据库，再删缓存。为什么是删缓存而非写缓存呢？因为有时缓存的结果是经过复杂计算得到的，而且可能是冷数据。这个就是lazy计算的思想，需要用到时才去计算。

**初步问题**：如果缓存删除失败，那么缓存里的就是旧数据

- 解决方法：先删除缓存。这样就不会不一致了

**进阶问题**：删了缓存还没修改数据库时，一个请求过来读取了数据库里的旧数据，然后写入缓存，导致不一致。

- 问题发生场景：**高并发时**
- 解决方法：根据请求所需的数据的唯一标志将请求写到**内存队列**中，每个队列由一个工作线程串行处理
  - 优化点：可以合并对同一个数据的更新

**进阶问题2**：如果频繁更新数据，那么读请求会大量超时

- 解决办法：多模拟真实数据来做压力测试，如果压力太大就加机器多分一些内存队列